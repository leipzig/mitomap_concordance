---
title: "The MITOMAP Concordance"
author: "Jeremy Leipzig"
date: "April 30, 2015"
output: html_document
---

MITOMAP conducts periodic analysis of all full length (>15.4kbp) mitochondrial sequences in GenBank. This involves processing the nearly 30k sequences through MITOMASTER. While no means an unbiased survey, the GenBank set offers some interesting opportunities to study human mitochondrial variability.

```{r}
library(ggplot2)
library(dplyr)
library(RPostgreSQL)
library(stringr)
library(SNPlocs.Hsapiens.dbSNP141.GRCh38)
library(gdsfmt)
library(SNPRelate)
library(Matrix)

con <- dbConnect(PostgreSQL(), user= "mitoreadonly", password="pzme93$.", dbname="mito", host="rescommapdb01.research.chop.edu")

rs <- dbSendQuery(con,"select distinct on (genbank_count.pos,genbank_count.ref,genbank_count.alt,genbank_count.haplogroup,genbank_count.cnt) genbank_count.*, common_name as locus, type from mitomap.genbank_count LEFT JOIN mitomaster.locus ON (starting <= ending AND starting<=pos AND ending>=pos) OR (ending < starting AND (pos <=ending OR pos >=starting)) ORDER BY pos, ref, alt, haplogroup, cnt, locus_id")
genbank_count <- fetch(rs, n = -1) # extract all rows

types<-list("n"="non-coding","t"="tRNA","m"="coding","r"="rRNA")
genbank_count$type<-sapply(genbank_count$type,function(x){types[[x]]})


# > head(genbank_count)
#   pos ref alt haplogroup cnt common_name
# 1   5   A   C         B2   1         ATT
# 2   5   A   C        H65   1         ATT
# 3   8   G   T       M33a   2         ATT
# 4   9   G   A        B2g   1         ATT
# 5   9   G   A          C   2         ATT
# 6   9   G   A        F2b   2         ATT
```

Variant frequency by position

```{r, echo=FALSE}
by_pos <- group_by(genbank_count, pos, locus, type)
hist_pos <- summarise(by_pos,variants=sum(cnt))
#ggplot(data=hist_pos,aes(pos,variants))+geom_point(stat="identity")
#http://www.gettinggeneticsdone.com/2013/11/a-mitochondrial-manhattan-plot.html
#https://github.com/hadley/ggplot2/wiki/Plotting-Mitochondrial-Genetic-Association-Results
p <- ggplot(hist_pos, aes(x = pos,y = variants,color = type)) + geom_point()+ coord_polar(direction = -1) 
print(p)

#+ geom_line(aes(x,1.30,color = "red"),data = lines) + facet_grid(.~race2) + geom_line(aes(y=extraline)) + geom_point(aes(x,y,color = gene),data=lines) + scale_colour_manual(values = #colours,"Genes",breaks = c("Control-Region","tRNA","rRNA","Non-Coding","ND1","ND2","CO1","CO2","ATP8","ATP6","CO3","ND3","ND4L","ND4","ND5","ND6","CYB"),labels = c("Control #Region","tRNA","rRNA","Non-Coding","ND1","ND2","CO1","CO2","ATP8","ATP6","CO3","ND3","ND4L","ND4","ND5","ND6","CYB"))+ opts(title = "Negative Log P-value of Mitochondrial Hits", #axis.text.x = theme_blank(), axis.title.y = theme_blank(), axis.title.x=theme_blank()) + layer(geom="text",mapping =aes(x,y,label = x),data = bdries,size=2.5)
```

Most common variants
```{r, echo=FALSE}
by_var_group <- group_by(genbank_count, pos, ref, alt, locus, type)
by_var_cnt <- summarise(by_var_group,variants=sum(cnt))

```

Despite what this paper says A8860G is not a rare polymorphism at all.
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3258716/

Most and least conserved loci


Which haplogroups have the most private mutations
```{r, echo=FALSE}
europe<-c("H","I","J","K","R","T","U","V","W","X")
africa<-c("L0","L1","L2","L3","L4","L5","L6")
asia<-c("F","B","P","A","S","O","Y","N","M","Q","G","E","D","C","Z")
genbank_count$region<-NA
#assign europe, africa, asia to variants
classify_haplogroups<-function(region_str){
  #get the vector of hap prefixes from the region
  #iterate over the prefixes and assign them all this region e.g. "europe"
  sapply(eval(parse(text=region_str)),function(a_haplogroup_prefix){
    str_detect(genbank_count$haplogroup,paste('^',a_haplogroup_prefix,sep=""))
  })
}

  sapply(europe,function(a_haplogroup_prefix){
    str_detect(genbank_count$haplogroup,paste('^',a_haplogroup_prefix,sep=""))
  })


aggs<-function(region){
agg<-list()
agg[["europe"]] <- "substring(haplogroup from 1 for 1)"
agg[["asia"]]   <- agg[["europe"]]
agg[["africa"]] <- "substring(haplogroup from 1 for 2)"
return(agg[[region]])
}

conditions<-function(region){paste((str_replace_all(region,pattern = "(.+)",replacement="OR haplogroup LIKE '\\1%'")),collapse=" ")}

do_region<-function(region){
select_sql<-paste("SELECT ",aggs(region),", COUNT(*) as cnt FROM mitomap.genbank_haplogroup WHERE False")
group_by<-paste("GROUP BY",aggs(region)," ORDER BY cnt DESC")
sql<-paste(select_sql,conditions(eval(parse(text = region))),group_by)
rs <- dbSendQuery(con,sql)
results<-fetch(rs,n=-1)
results$percent<-round(prop.table(results$cnt)*100,2)
names(results)<-c("Haplogroup","Count","Percent")
results
}
```

How do the genbank sequences stratify using a Principal Component Analysis? We would expect the major haplogroups to cluster.

"The functions in SNPRelate for PCA include calculating the genetic covariance matrix from genotypes, computing the correlation coefficients between sample loadings and genotypes for each SNP, calculating SNP eigenvectors (loadings), and estimating the sample loadings of a new dataset from specified SNP eigenvectors."

```{r, echo=FALSE}
rs <- dbSendQuery(con,"select genbank_id, tpos, tnt, qnt from mitomap.genbank")
gball <- fetch(rs, n = -1) # extract all rows
gball$qnt[gball$qnt==':']<-'d'
gball$snpid<-paste(gball$tnt,gball$tpos,gball$qnt,sep="")
dbDisconnect(con)

#The minimum required variables are

#sample.id, a unique identifier for each sample.
#snp.id, a unique identifier for each SNP.
#snp.position, the base position of each SNP on the chromosome, and 0 for unknown position; it does not allow NA.
#snp.chromosome
#genotype, a SNP genotypic matrix. SNP-major mode: nsample×nsnp, individual-major mode: nsnp×nsample.
# Create a gds file
# The first argument should be a numeric matrix for SNP genotypes. There are possible values stored in the input genotype matrix: 0, 1, 2 and other values. “0” indicates two B alleles, “1” indicates one A allele and one B allele, “2” indicates two A alleles, and other values indicate a missing genotype. The SNP matrix can be either nsample×nsnp (snpfirstdim=FALSE, the argument in snpgdsCreateGeno()) or nsnp×nsample (snpfirstdim=TRUE).

gbfac<-gball
gbfac$genbank_id<-as.factor(gbfac$genbank_id)
gbfac$snpid<-as.factor(gbfac$snpid)
gbfac$tpos<-as.factor(gbfac$tpos)
sparsey<-sparseMatrix(i = as.numeric(gbfac$genbank_id), j = as.numeric(gbfac$snpid))

#convert logical matrix into 0's and 1's (not biallelic anyway)
#haha genius https://stat.ethz.ch/pipermail/r-help/2011-January/265121.html
numsparsey<-1*as.matrix(sparsey)

#extract the position 73 from A73G 
pos<-as.numeric(gsub("[A-Z]+([0-9]+).+", "\\1", levels(gbfac$snpid)))

#extract the G from A73G
alleles<-as.character(gsub("[A-Z]+[0-9]+(.+)", "\\1", levels(gbfac$snpid)))

#create the gds file
genos<-snpgdsCreateGeno("mitogb.gds", genmat = numsparsey,
    sample.id = levels(gbfac$genbank_id), snp.id = levels(gbfac$snpid),
    snp.chromosome = rep('MT',length(levels(gbfac$snpid))),
    snp.position = pos,
    snp.allele = alleles, snpfirstdim=FALSE)

genofile <- snpgdsOpen("mitogb.gds")

#plot the PCA
#RV <- snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16)


```

There are `r length(unique(gball$snpid))` mutations in the GenBank set over `r length(unique(gball$tpos))` which is a rate of `r length(unique(gball$tpos))/16568` per bp. `sum(table(gbfac$snpid)==1)` of these belong to only one sequence.

So in contrast to the nuclear genes 51,217,066 rs numbers in dbSNP out of 3,064,641,871 non-N bases which is a rate of `r 51217066/3064641871`

D-Loop gets triple stranded during replication, with hypervariable regions

phenylanlinian to proline is with coding areas
within coding regions breakout tRNA




How many MT snps are in dbSNP?
```{r, echo=FALSE}

snps <- SNPlocs.Hsapiens.dbSNP141.GRCh38
chMTsnps <- snplocs(snps,"chMT")
```

There are `r as.numeric(snpcount(snps)[["chMT"]])` mitochondrial snp positions in dbSNP and `r length(unique(sort(gball$tpos)))`

There are `r length(unique(gball$snpid))` distinct mutations in the gb set.

sum(unique(sort(chMTsnps$loc)) %in% unique(sort(gball$tpos)))
sum(unique(sort(gball$tpos)) %in% unique(sort(chMTsnps$loc)))
library(Vennerable)

3243A>G mutation
