---
title: "The MITOMAP Concordance"
author: "Jeremy Leipzig"
date: "April 30, 2015"
output: html_document
---

MITOMAP conducts periodic analysis of all full length (>15.4kbp) mitochondrial sequences in GenBank. This involves processing the nearly 30k sequences through MITOMASTER. While no means an unbiased survey, the GenBank set offers some interesting opportunities to study human mitochondrial variability.

```{r}
library(ggplot2)
library(dplyr)
library(RPostgreSQL)
library(stringr)
library(SNPlocs.Hsapiens.dbSNP141.GRCh38)
library(gdsfmt)
library(SNPRelate)
library(Matrix)
library(knitr)
library(RColorBrewer)
library("Biostrings")


# > head(genbank_count)
#   pos ref alt haplogroup cnt common_name
# 1   5   A   C         B2   1         ATT
# 2   5   A   C        H65   1         ATT
# 3   8   G   T       M33a   2         ATT
# 4   9   G   A        B2g   1         ATT
# 5   9   G   A          C   2         ATT
# 6   9   G   A        F2b   2         ATT
```

Variant frequency by position

```{r, echo=FALSE}
#ggplot(data=hist_pos,aes(pos,variants))+geom_point(stat="identity")
#http://www.gettinggeneticsdone.com/2013/11/a-mitochondrial-manhattan-plot.html
#https://github.com/hadley/ggplot2/wiki/Plotting-Mitochondrial-Genetic-Association-Results

by_pos <- group_by(genbank_count, pos, locus, type, pretty_name)
hist_pos <- summarise(by_pos,maf=sum(cnt)*100/nrow(gbhap),ln_tot=log(sum(cnt)))

#these are the outer band of gene labels
gene_lines <- data.frame(pos = seq(1,16569,by=1),y = 100)
gene_lines$locus<-sapply(gene_lines$pos,get_locus)
gene_lines$type<-sapply(gene_lines$pos,get_type)
gene_lines$pretty_name<-apply(gene_lines,1,get_pretty_name)
group_by(gene_lines,pretty_name) %>%   filter(pretty_name != 'rRNA' & pretty_name != 'tRNA' & pretty_name != 'non-coding') %>% summarize(pos=mean(pos)) -> bdries
bdries[bdries$pretty_name=='D-Loop/Control Region',"pos"]<-50
bdries$y<-105

ggplot(hist_pos, aes(x = pos,y = maf,color = pretty_name)) + geom_point()+ coord_polar(direction = -1) + geom_point(data=gene_lines,aes(pos,y,color = pretty_name)) + scale_colour_manual(values = colours,"Loci",breaks = c("D-Loop/Control Region","tRNA","rRNA","non-coding","ND1","ND2","COI","COII","ATPase8","ATPase6","COIII","ND3","ND4L","ND4","ND5","ND6","Cytb"), labels = c("D-Loop/Control Region","tRNA","rRNA","non-coding","ND1","ND2","COI","COII","ATPase8","ATPase6","COIII","ND3","ND4L","ND4","ND5","ND6","Cytb")) +
xlab("Mitochondrial Base-Pair Location") +
ylab("MAF") +
ggtitle("MAF of Mitochondrial GenBank Variants") +
layer(geom="text",mapping =aes(pos,y,label = pretty_name),data = bdries,size=2.5)
```

Most common variants
```{r, echo=FALSE}
by_var_group <- group_by(genbank_count, pos, ref, alt, locus, type)

by_var_cnt <- summarise(by_var_group,variants=sum(cnt))

```

Despite what this paper says A8860G is not a rare polymorphism at all.
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3258716/

Most and least conserved loci (over 20 bp, beware overlapping annotation)
```{r, echo=FALSE}
group_by(genbank_count, locus, type) %>% mutate(length=get_length(locus)) %>% summarise(total_variants=sum(cnt),rate=sum(cnt)/mean(length),length=mean(length)) -> loci_conservation
```
Least Conserved
```{r, echo=FALSE}
kable(subset(loci_conservation[order(-loci_conservation$rate),],length>20))
```
Most Conserved
```{r, echo=FALSE}
kable(subset(loci_conservation[order(loci_conservation$rate),],length>20))
```

Multiple regressions are evident by locus type
```{r, echo=FALSE}
ggplot(loci_conservation,aes(length,total_variants,color=type))+geom_point()+geom_smooth( method=lm, se=FALSE)
```

Which haplogroups have the most private mutations
```{r, echo=FALSE}
europe<-c("H","I","J","K","R","T","U","V","W","X")
africa<-c("L0","L1","L2","L3","L4","L5","L6")
asia<-c("F","B","P","A","S","O","Y","N","M","Q","G","E","D","C","Z")
all_prefixes<-c(europe,africa,asia)
#assign europe, africa, asia to variants
#get the vector of hap prefixes from the region
#iterate over the prefixes and assign them all this region e.g. "europe"
get_region<-function(any_gb_table){
    any_gb_table$region<-NA
      get_region_logical_lists<-function(regionprefixes){
        lapply(regionprefixes,function(a_haplogroup_prefix){
          str_detect(any_gb_table$haplogroup,paste('^',a_haplogroup_prefix,sep=""))
      })
    }
  any_gb_table[Reduce("|",get_region_logical_lists(asia)),"region"]<-"Asia"
  any_gb_table[Reduce("|",get_region_logical_lists(africa)),"region"]<-"Africa"
  any_gb_table[Reduce("|",get_region_logical_lists(europe)),"region"]<-"Europe"
  return(any_gb_table)
}

#just return the prefix i.e. A15c is A, L1c is L1
#takes the first but returns a vector of equal length
prefix_pats<-paste('^',all_prefixes,sep="")
return_prefix<-function(haplogroup){
  all_prefixes[which(!is.na(str_locate(haplogroup[1],prefix_pats)[,"start"]))]
}
# aggs<-function(region){
#   agg<-list()
#   agg[["europe"]] <- "substring(haplogroup from 1 for 1)"
#   agg[["asia"]]   <- agg[["europe"]]
#   agg[["africa"]] <- "substring(haplogroup from 1 for 2)"
#   return(agg[[region]])
# }
# 
# conditions<-function(region){paste((str_replace_all(region,pattern = "(.+)",replacement="OR haplogroup LIKE '\\1%'")),collapse=" ")}
# 
# do_region<-function(region){
#   select_sql<-paste("SELECT ",aggs(region),", COUNT(*) as cnt FROM mitomap.genbank_haplogroup WHERE False")
#   group_by<-paste("GROUP BY",aggs(region)," ORDER BY cnt DESC")
#   sql<-paste(select_sql,conditions(eval(parse(text = region))),group_by)
#   rs <- dbSendQuery(con,sql)
#   results<-fetch(rs,n=-1)
#   results$percent<-round(prop.table(results$cnt)*100,2)
#   names(results)<-c("Haplogroup","Count","Percent")
#   results
# }
```

How do the genbank sequences stratify using a Principal Component Analysis? We would expect the major haplogroups to cluster.

PCA is really a geometric operation in which they use an operation to find a few which variables tend to flock together, starting with the one that produces the most variance. You can generally a lot of principal components but generally you just look at the first two to keep things in 2D.


"The functions in SNPRelate for PCA include calculating the genetic covariance matrix from genotypes, computing the correlation coefficients between sample loadings and genotypes for each SNP, calculating SNP eigenvectors (loadings), and estimating the sample loadings of a new dataset from specified SNP eigenvectors."

In a normal PCA the covariance matrix is composed of scalars, but you can generate a PCA of SNPs for biallelic you would generally score homozygous alternate as 2, hemizygous as 1, and all reference as 0. With the mitochondria we just score REF and ALT.
```{r, echo=FALSE}


gball$qnt[gball$qnt==':']<-'d'
gball$snpid<-paste(gball$tnt,gball$tpos,gball$qnt,sep="")
gball<-get_region(gball)
gball %>% group_by(haplogroup) %>% mutate(prefix = return_prefix(haplogroup)) %>% ungroup -> gball

gbfac<-gball
gbfac$genbank_id<-as.factor(gbfac$genbank_id)
gbfac$snpid<-as.factor(gbfac$snpid)
gbfac$tpos<-as.factor(gbfac$tpos)



gbhap<-get_region(gbhap)
gbhap %>% group_by(haplogroup) %>% mutate(prefix = return_prefix(haplogroup)) %>% ungroup -> gbhap

```
The breakdown of GenBank sequences by region
```{r, echo=FALSE}
kable(as.data.frame(table(gbhap$region)))
```
Which regions have the most private mutations? i.e. how many haplogroups fall slightly outside of Phylotree?
```{r, echo=FALSE}
kable(prop.table(table(str_detect(gbhap$haplogroup_verbose,'\\+'),gbhap$region),2)*100)
```

Which haplogroups have the most disease entries?
These are the proportion of disease variants among all variants for each of these populations
```{r, echo=FALSE}
prop.table(table(gball$ismmut,gball$region),2)

prop.table(table(gball$ismmut,gball$prefix),2)
#these are out of the more than 1 million variants among the entire set
```
Many diseases have very different rates by region

These are dominated by major depressive associated mtuation in Asia
Altered brain pH in Europeans
LHON disorders all pretty high in Europenas
```{r, echo=FALSE}
gball$disease_anno<-ifelse(gball$disease=='','',paste(gball$disease,gball$snpid))
kable(round(prop.table(table(gball$disease_anno[gball$disease_anno!=''],gball$region[gball$disease_anno!='']))*100,digits=3))
```

prop.table(table(gball$disease[gball$disease_anno!=''],gball$region[gball$disease_anno!='']))*100,digits=3)

table(gball$disease[gball$disease_anno!=''],gball$region[gball$disease_anno!=''])
#can we set up contigency tables
numAfr<-table(gbhap$region)[['Africa']]
numEur<-table(gbhap$region)[['Europe']]
numAsia<-table(gbhap$region)[['Asia']]

fishme<-function(x){
  afr<-as.numeric(x[['Africa']])
  afr_nosnp<-numAfr-afr
  
  nonafr<-as.numeric(x[['Europe']])+as.numeric(x[['Asia']])
  nonafr_nosnp<-numEur+numAsia-nonafr
  
  disease<-matrix(c(afr,nonafr,afr_nosnp,nonafr_nosnp),
       nrow = 2,
       dimnames = list(SNP = c("Afr", "Non-Afr"),
                       NoSNP = c("Afr", "Non-Afr")))
  fisher.test(disease, alternative = "two.sided")[['p.value']]
}

afr_disease_pvals<-apply(table(gball$disease_anno[gball$disease_anno!=''],gball$region[gball$disease_anno!='']),1,fishme)
adj_afr_disease_pvals<-p.adjust(afr_disease_pvals, method = 'BH')

#there are many that segregate by population
adj_afr_disease_pvals_below_thresh<-adj_afr_disease_pvals[adj_afr_disease_pvals<0.01]

kable(sort(adj_afr_disease_pvals_below_thresh))
```{r, echo=FALSE}
#The minimum required variables are

#sample.id, a unique identifier for each sample.
#snp.id, a unique identifier for each SNP.
#snp.position, the base position of each SNP on the chromosome, and 0 for unknown position; it does not allow NA.
#snp.chromosome
#genotype, a SNP genotypic matrix. SNP-major mode: nsample×nsnp, individual-major mode: nsnp×nsample.
# Create a gds file
# The first argument should be a numeric matrix for SNP genotypes. There are possible values stored in the input genotype matrix: 0, 1, 2 and other values. “0” indicates two B alleles, “1” indicates one A allele and one B allele, “2” indicates two A alleles, and other values indicate a missing genotype. The SNP matrix can be either nsample×nsnp (snpfirstdim=FALSE, the argument in snpgdsCreateGeno()) or nsnp×nsample (snpfirstdim=TRUE).


#can we reduce this a bit?
snpidsForPCA<-table(gbfac$snpid)[intersect(which(table(gbfac$snpid)<20000),which(table(gbfac$snpid)>20))]

sparsey<-sparseMatrix(i = as.numeric(gbfac$genbank_id), j = as.numeric(gbfac$snpid))

#convert logical matrix into 0's and 1's (not biallelic anyway)
#haha genius https://stat.ethz.ch/pipermail/r-help/2011-January/265121.html
numsparsey<-1*as.matrix(sparsey)

#extract the position 73 from A73G 
pos<-as.numeric(gsub("[A-Z]+([0-9]+).+", "\\1", levels(gbfac$snpid)))

#extract the G from A73G
alleles<-as.character(gsub("[A-Z]+[0-9]+(.+)", "\\1", levels(gbfac$snpid)))

#create the gds file
#26 is MT FWIW
if (! file.exists("mito_gb.gds")){
  snpgdsCreateGeno("mitogb.gds", genmat = numsparsey,
      sample.id = levels(gbfac$genbank_id), snp.id = levels(gbfac$snpid),
      snp.chromosome = rep(26,length(levels(gbfac$snpid))),
      snp.position = pos,
      snp.allele = alleles, snpfirstdim=FALSE)
}
genofile <- snpgdsOpen("mitogb.gds")

#take all snps
snp_subset<-levels(gbfac$snpid)

MASTER_SAMPLE_NUMBER<-500
if(MASTER_SAMPLE_NUMBER){
  sample_subset<-levels(gbfac$genbank_id)[sample(1:length(levels(gbfac$genbank_id)),MASTER_SAMPLE_NUMBER)]
}else{
  sample_subset<-levels(gbfac$genbank_id)
}
  
PCA<-snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,eigen.cnt=2,sample.id = sample_subset,snp.id = snp_subset)

gbhap$africa_breakdown<-apply(gbhap,1,function(x){if(x['region']=='Africa'){return(x['prefix'])}else{return(x['region'])}})


tab <- data.frame(sample.id = PCA$sample.id,
                  pop = gbhap[match(PCA$sample.id,gbhap$genbank_id),"region"],
                  pre = gbhap[match(PCA$sample.id,gbhap$genbank_id),"prefix"],
                  afronly = gbhap[match(PCA$sample.id,gbhap$genbank_id),"africa_breakdown"],
    EV1 = PCA$eigenvect[,1],    # the first eigenvector
    EV2 = PCA$eigenvect[,2],    # the second eigenvector
    stringsAsFactors = FALSE)
tab$region<- factor(tab$region, levels = c("Asia", "Europe", "Africa"))
tab$africa_breakdown<- factor(tab$africa_breakdown, levels = c("Asia", "Europe", "L0", "L1","L2","L3","L4","L5","L6"))


myColors <- brewer.pal(9,"Set1")
names(myColors) <- levels(tab$region)
colScale <- scale_colour_manual(name = "region",values = myColors)

ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=region))+colScale
```
The regional PCA is interesting. If we provide a breakdown just by Africa:
```{r, echo=FALSE}
names(myColors) <- levels(tab$africa_breakdown)
colScale <- scale_colour_manual(name = "africa_breakdown",values = myColors)
ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=africa_breakdown))+colScale

if(MASTER_SAMPLE_NUMBER){
  africa_only<-levels(factor(gbfac$genbank_id[gbfac$region=='Africa']))[sample(1:length(levels(factor(gbfac$genbank_id[gbfac$region=='Africa']))),MASTER_SAMPLE_NUMBER)]
}else{
  africa_only<-levels(factor(gbfac$genbank_id[gbfac$region=='Africa']))

}
my_subset<-africa_only
```
This makes more sense if we view. L0
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2427203/bin/gr1.jpg


Now let's just at PCAs of the regions
```{r doregion, echo=FALSE}

PCA<-snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,eigen.cnt=2,sample.id = my_subset,snp.id = snp_subset)
tab <- data.frame(sample.id = PCA$sample.id,
                  pop = gbhap[match(PCA$sample.id,gbhap$genbank_id),"region"],
                  pre = gbhap[match(PCA$sample.id,gbhap$genbank_id),"prefix"],
    EV1 = PCA$eigenvect[,1],    # the first eigenvector
    EV2 = PCA$eigenvect[,2],    # the second eigenvector
    stringsAsFactors = FALSE)
ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=prefix))

```
Europe
```{r, echo=FALSE}
if(MASTER_SAMPLE_NUMBER){
my_subset<-levels(factor(gbfac$genbank_id[gbfac$region=='Europe']))[sample(1:length(levels(factor(gbfac$genbank_id[gbfac$region=='Europe']))),MASTER_SAMPLE_NUMBER)]
}else{
  my_subset<-levels(factor(gbfac$genbank_id[gbfac$region=='Europe']))
}
```

```{r europe, ref.label='doregion'}
```

#plot the PCA
#RV <- snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16)


#RV <- snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,missing.rate=.1,eigen.cnt=2)

```

There are `r length(unique(gball$snpid))` mutations in the GenBank set over `r length(unique(gball$tpos))` which is a rate of `r length(unique(gball$tpos))/16568` per bp. `sum(table(gbfac$snpid)==1)` of these are truly priviate mutations belonging to only one sequence.

So in contrast to the nuclear genes 51,217,066 rs numbers in dbSNP out of 3,064,641,871 non-N bases which is a rate of `r 51217066/3064641871`

D-Loop gets triple stranded during replication, with hypervariable regions

phenylanlinian to proline is with coding areas
within coding regions breakout tRNA




How many MT snps are in dbSNP?
```{r, echo=FALSE}

snps <- SNPlocs.Hsapiens.dbSNP141.GRCh38
chMTsnps <- snplocs(snps,"chMT")
```

There are `r as.numeric(snpcount(snps)[["chMT"]])` mitochondrial snp positions in dbSNP and `r length(unique(sort(gball$tpos)))`

There are `r length(unique(gball$snpid))` distinct mutations in the gb set.

sum(unique(sort(chMTsnps$loc)) %in% unique(sort(gball$tpos)))
sum(unique(sort(gball$tpos)) %in% unique(sort(chMTsnps$loc)))
library(Vennerable)

3243A>G mutation


Are there associations between SNPs that are not defined by the haplogroups themselves? Market basket analysis is one way to look at this, where we consider that we have 30,000 shoppers choosing among 9919 SNPs. Market basket is a type of association rule mining using in economics, this is often called the diapers and beer study, since it discovered those two items are strongly associated.

In most cases this type of analysis on SNPs alone will usually only reveal the existing haplogroup structure or (they simply identify the equivalent of tag SNPs), so it is perhaps most interesting when we view SNPs that span multiple regions and have low penetrance. It is conceivable that certain mutations convergent evolution toward similar combinations of SNPs that this can reveal.

If we combine it with phenotype it might be able to reveal combinations of SNPs that would escape GWAS, especially if we have a few haplogroups with elevated rates of a disease.

```{r, echo=FALSE}
imatrix<-as(numsparsey, "itemMatrix")
dimnames(imatrix)[[1]]<-levels(gbfac$genbank_id)

dimnames(imatrix)[[2]]<-levels(gbfac$snpid)

rules <- apriori(imatrix)
summary(rules)
rules.sorted<-sort(rules,by="lift")

disease_snps<-str_extract(names(sort(adj_afr_disease_pvals_below_thresh)),'\\S+$')

getRules<-function(snp){
  rules <- apriori(imatrix,appearance = list(rhs=snp,default='lhs'))
  return(length(rules))
}

disease_rules<-lapply(disease_snps,getRules)
```

What about conservation? There is little correlation between intra and inter species conservation at the gene level.
```{r, echo=FALSE}
filename<-"mito-conservation-index/makeTables/39MSAs/35_CYTB.fa"
seqs<-readAAStringSet(filename)
str_extract(filename,"([0-9]+)_([A-Za-z0-9]+).fa")
matches<-str_match(filename,"([0-9]+)_([A-Za-z0-9]+).fa")
loci<-matches[2]
commonName<-matches[3]
seqMatrix<-as.matrix(seqs)
#i don't care for gaps
seqMatrix<-seqMatrix[,-which(seqMatrix[1,]=='-')]
of39<-apply(seqMatrix,2,FUN=function(x){length(which(x==x[1]))})
df<-data.frame(loci=loci,common=commonName,aa_pos=1:length(of39),of39=of39)
#write.table(df,file=outfile,sep="\t",quote=FALSE,row.names=FALSE)
#confirmRCSlen<-paste(seqMatrix[1,],collapse="")
#write(confirmRCSlen,file=paste('geneSizes/',commonName,':',str_length(confirmRCSlen),'bp',sep=""))
of39df<-data.frame(x=1:length(of39),inter=(39-of39)*100/39)

#try to put his in AA coords
genbank_count %>% filter(locus=='Cytb') %>% group_by(x=floor((pos-14749)/3)+1) %>% summarize(intra=sum(cnt)*100/nrow(gbhap)) -> cytb_conservation

bycytb<-merge(of39df,cytb_conservation,by="x",all.x=TRUE)
#no snps
bycytb[is.na(bycytb$intra),"intra"]<-0
melt_bycytb<-melt(bycytb,id="x")
ggplot(melt_bycytb,aes(x=x,y=value))+geom_point(aes(color=variable))+xlab("AA_pos")+ylab("Pseudo-MAF")+title("Cytb")
```

```{r, echo=FALSE}

```