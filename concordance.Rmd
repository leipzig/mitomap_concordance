---
title: "The MITOMAP Concordance"
author: "Jeremy Leipzig"
date: "April 30, 2015"
output: html_document
---

MITOMAP conducts periodic analysis of all full length (>15.4kbp) mitochondrial sequences in GenBank. This involves processing the nearly 30k sequences through MITOMASTER. While no means an unbiased survey, the GenBank set offers some interesting opportunities to study human mitochondrial variability.

```{r}
library(ggplot2)
library(dplyr)
library(RPostgreSQL)
library(stringr)
library(SNPlocs.Hsapiens.dbSNP141.GRCh38)
library(gdsfmt)
library(SNPRelate)
library(Matrix)
library(knitr)
library(RColorBrewer)

con <- dbConnect(PostgreSQL(), user= "mitoreadonly", password="pzme93$.", dbname="mito", host="rescommapdb01.research.chop.edu")

rs <- dbSendQuery(con,"select distinct on (locus_id, genbank_count.pos,genbank_count.ref,genbank_count.alt,genbank_count.haplogroup,genbank_count.cnt) genbank_count.*, common_name as locus, type from mitomap.genbank_count LEFT JOIN mitomaster.locus ON (starting <= ending AND starting<=pos AND ending>=pos) OR (ending < starting AND (pos <=ending OR pos >=starting)) ORDER BY locus_id, pos, ref, alt, haplogroup, cnt, locus_id")
genbank_count <- fetch(rs, n = -1) # extract all rows

rs <- dbSendQuery(con,"select genbank_id, haplogroup, haplogroup_verbose from mitomap.genbank_haplogroup")
gbhap <- fetch(rs, n = -1) # extract all rows

rs <- dbSendQuery(con,"select genbank_id, tpos, tnt, qnt, haplogroup, disease, ismmut from mitomap.genbank")
gball <- fetch(rs, n = -1) # extract all rows

types<-list("n"="non-coding","t"="tRNA","m"="coding","r"="rRNA")
genbank_count$type<-sapply(genbank_count$type,function(x){types[[x]]})

rs <-  dbSendQuery(con,"select * from mitomaster.locus")
loci <-  fetch(rs, n = -1) # extract all rows
getlocilengths<-function(x){
  if(as.integer(x['ending'])>=as.integer(x['starting'])){
    return(as.integer(x['ending'])-as.integer(x['starting'])+1)
  }else{
    return((16569-as.integer(x['starting']))+as.integer(x['ending'])+1)
  }
}

loci$length<-apply(loci,1,getlocilengths)
get_length<-function(locus){
  return(as.integer(loci[loci$common_name==locus[1],"length"]))
}
# > head(genbank_count)
#   pos ref alt haplogroup cnt common_name
# 1   5   A   C         B2   1         ATT
# 2   5   A   C        H65   1         ATT
# 3   8   G   T       M33a   2         ATT
# 4   9   G   A        B2g   1         ATT
# 5   9   G   A          C   2         ATT
# 6   9   G   A        F2b   2         ATT
```

Variant frequency by position

```{r, echo=FALSE}
by_pos <- group_by(genbank_count, pos, locus, type)
hist_pos <- summarise(by_pos,maf=sum(cnt)*100/nrow(gbhap),ln_tot=log(sum(cnt)))
#ggplot(data=hist_pos,aes(pos,variants))+geom_point(stat="identity")
#http://www.gettinggeneticsdone.com/2013/11/a-mitochondrial-manhattan-plot.html
#https://github.com/hadley/ggplot2/wiki/Plotting-Mitochondrial-Genetic-Association-Results
p <- ggplot(hist_pos, aes(x = pos,y = maf,color = type)) + geom_point()+ coord_polar(direction = -1) 
print(p)

#+ geom_line(aes(x,1.30,color = "red"),data = lines) + facet_grid(.~race2) + geom_line(aes(y=extraline)) + geom_point(aes(x,y,color = gene),data=lines) + scale_colour_manual(values = #colours,"Genes",breaks = c("Control-region","tRNA","rRNA","Non-Coding","ND1","ND2","CO1","CO2","ATP8","ATP6","CO3","ND3","ND4L","ND4","ND5","ND6","CYB"),labels = c("Control #region","tRNA","rRNA","Non-Coding","ND1","ND2","CO1","CO2","ATP8","ATP6","CO3","ND3","ND4L","ND4","ND5","ND6","CYB"))+ opts(title = "Negative Log P-value of Mitochondrial Hits", #axis.text.x = theme_blank(), axis.title.y = theme_blank(), axis.title.x=theme_blank()) + layer(geom="text",mapping =aes(x,y,label = x),data = bdries,size=2.5)
```

Most common variants
```{r, echo=FALSE}
by_var_group <- group_by(genbank_count, pos, ref, alt, locus, type)

by_var_cnt <- summarise(by_var_group,variants=sum(cnt))

```

Despite what this paper says A8860G is not a rare polymorphism at all.
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3258716/

Most and least conserved loci (over 20 bp, beware overlapping annotation)
```{r, echo=FALSE}
group_by(genbank_count, locus, type) %>% mutate(length=get_length(locus)) %>% summarise(total_variants=sum(cnt),rate=sum(cnt)/mean(length),length=mean(length)) -> loci_conservation
```
Least Conserved
```{r, echo=FALSE}
kable(subset(loci_conservation[order(-loci_conservation$rate),],length>20))
```
Most Conserved
```{r, echo=FALSE}
kable(subset(loci_conservation[order(loci_conservation$rate),],length>20))
```

Multiple regressions are evident by locus type
```{r, echo=FALSE}
ggplot(loci_conservation,aes(length,total_variants,color=type))+geom_point()+geom_smooth( method=lm, se=FALSE)
```

Which haplogroups have the most private mutations
```{r, echo=FALSE}
europe<-c("H","I","J","K","R","T","U","V","W","X")
africa<-c("L0","L1","L2","L3","L4","L5","L6")
asia<-c("F","B","P","A","S","O","Y","N","M","Q","G","E","D","C","Z")
all_prefixes<-c(europe,africa,asia)
#assign europe, africa, asia to variants
#get the vector of hap prefixes from the region
#iterate over the prefixes and assign them all this region e.g. "europe"
get_region<-function(any_gb_table){
    any_gb_table$region<-NA
      get_region_logical_lists<-function(regionprefixes){
        lapply(regionprefixes,function(a_haplogroup_prefix){
          str_detect(any_gb_table$haplogroup,paste('^',a_haplogroup_prefix,sep=""))
      })
    }
  any_gb_table[Reduce("|",get_region_logical_lists(asia)),"region"]<-"Asia"
  any_gb_table[Reduce("|",get_region_logical_lists(africa)),"region"]<-"Africa"
  any_gb_table[Reduce("|",get_region_logical_lists(europe)),"region"]<-"Europe"
  return(any_gb_table)
}

#just return the prefix i.e. A15c is A, L1c is L1
#takes the first but returns a vector of equal length
prefix_pats<-paste('^',all_prefixes,sep="")
return_prefix<-function(haplogroup){
  all_prefixes[which(!is.na(str_locate(haplogroup[1],prefix_pats)[,"start"]))]
}
# aggs<-function(region){
#   agg<-list()
#   agg[["europe"]] <- "substring(haplogroup from 1 for 1)"
#   agg[["asia"]]   <- agg[["europe"]]
#   agg[["africa"]] <- "substring(haplogroup from 1 for 2)"
#   return(agg[[region]])
# }
# 
# conditions<-function(region){paste((str_replace_all(region,pattern = "(.+)",replacement="OR haplogroup LIKE '\\1%'")),collapse=" ")}
# 
# do_region<-function(region){
#   select_sql<-paste("SELECT ",aggs(region),", COUNT(*) as cnt FROM mitomap.genbank_haplogroup WHERE False")
#   group_by<-paste("GROUP BY",aggs(region)," ORDER BY cnt DESC")
#   sql<-paste(select_sql,conditions(eval(parse(text = region))),group_by)
#   rs <- dbSendQuery(con,sql)
#   results<-fetch(rs,n=-1)
#   results$percent<-round(prop.table(results$cnt)*100,2)
#   names(results)<-c("Haplogroup","Count","Percent")
#   results
# }
```

How do the genbank sequences stratify using a Principal Component Analysis? We would expect the major haplogroups to cluster.

PCA is really a geometric operation in which they use an operation to find a few which variables tend to flock together, starting with the one that produces the most variance. You can generally a lot of principal components but generally you just look at the first two to keep things in 2D.


"The functions in SNPRelate for PCA include calculating the genetic covariance matrix from genotypes, computing the correlation coefficients between sample loadings and genotypes for each SNP, calculating SNP eigenvectors (loadings), and estimating the sample loadings of a new dataset from specified SNP eigenvectors."

In a normal PCA the covariance matrix is composed of scalars, but you can generate a PCA of SNPs for biallelic you would generally score homozygous alternate as 2, hemizygous as 1, and all reference as 0. With the mitochondria we just score REF and ALT.
```{r, echo=FALSE}


gball$qnt[gball$qnt==':']<-'d'
gball$snpid<-paste(gball$tnt,gball$tpos,gball$qnt,sep="")
gball<-get_region(gball)
gball %>% group_by(haplogroup) %>% mutate(prefix = return_prefix(haplogroup)) %>% ungroup -> gball

gbfac<-gball
gbfac$genbank_id<-as.factor(gbfac$genbank_id)
gbfac$snpid<-as.factor(gbfac$snpid)
gbfac$tpos<-as.factor(gbfac$tpos)



gbhap<-get_region(gbhap)
gbhap %>% group_by(haplogroup) %>% mutate(prefix = return_prefix(haplogroup)) %>% ungroup -> gbhap

```
The breakdown of GenBank sequences by region
```{r, echo=FALSE}
kable(as.data.frame(table(gbhap$region)))
```
Which regions have the most private mutations? i.e. how many haplogroups fall slightly outside of Phylotree?
```{r, echo=FALSE}
kable(prop.table(table(str_detect(gbhap$haplogroup_verbose,'\\+'),gbhap$region),2)*100)
```

Which haplogroups have the most disease entries?

These are dominated by major depressive associated mtuation in Asia
Altered brain pH in Europeans
LHON disorders all pretty high in Europenas
```{r, echo=FALSE}
prop.table(table(gball$ismmut,gball$region),2)

prop.table(table(gball$ismmut,gball$prefix),2)
#these are out of the more than 1 million variants among the entire set
```
Many diseases have very different rates by region
```{r, echo=FALSE}
kable(round(prop.table(table(gball$disease[gball$disease!=''],gball$region[gball$disease!='']))*100,digits=3))
```

#The minimum required variables are

#sample.id, a unique identifier for each sample.
#snp.id, a unique identifier for each SNP.
#snp.position, the base position of each SNP on the chromosome, and 0 for unknown position; it does not allow NA.
#snp.chromosome
#genotype, a SNP genotypic matrix. SNP-major mode: nsample×nsnp, individual-major mode: nsnp×nsample.
# Create a gds file
# The first argument should be a numeric matrix for SNP genotypes. There are possible values stored in the input genotype matrix: 0, 1, 2 and other values. “0” indicates two B alleles, “1” indicates one A allele and one B allele, “2” indicates two A alleles, and other values indicate a missing genotype. The SNP matrix can be either nsample×nsnp (snpfirstdim=FALSE, the argument in snpgdsCreateGeno()) or nsnp×nsample (snpfirstdim=TRUE).


#can we reduce this a bit?
snpidsForPCA<-table(gbfac$snpid)[intersect(which(table(gbfac$snpid)<20000),which(table(gbfac$snpid)>20))]

sparsey<-sparseMatrix(i = as.numeric(gbfac$genbank_id), j = as.numeric(gbfac$snpid))

#convert logical matrix into 0's and 1's (not biallelic anyway)
#haha genius https://stat.ethz.ch/pipermail/r-help/2011-January/265121.html
numsparsey<-1*as.matrix(sparsey)

#extract the position 73 from A73G 
pos<-as.numeric(gsub("[A-Z]+([0-9]+).+", "\\1", levels(gbfac$snpid)))

#extract the G from A73G
alleles<-as.character(gsub("[A-Z]+[0-9]+(.+)", "\\1", levels(gbfac$snpid)))

#create the gds file
#26 is MT FWIW
if (! file.exists("mito_gb.gds")){
  snpgdsCreateGeno("mitogb.gds", genmat = numsparsey,
      sample.id = levels(gbfac$genbank_id), snp.id = levels(gbfac$snpid),
      snp.chromosome = rep(26,length(levels(gbfac$snpid))),
      snp.position = pos,
      snp.allele = alleles, snpfirstdim=FALSE)
}
genofile <- snpgdsOpen("mitogb.gds")
snp_subset<-levels(gbfac$snpid) #[sample(1:length(levels(gbfac$snpid)),5000)]
sample_subset<-levels(gbfac$genbank_id)[sample(1:length(levels(gbfac$genbank_id)),1000)]

PCA<-snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,eigen.cnt=2,sample.id = sample_subset,snp.id = snp_subset)

gbhap$africa_breakdown<-apply(gbhap,1,function(x){if(x['region']=='Africa'){return(x['prefix'])}else{return(x['region'])}})


tab <- data.frame(sample.id = PCA$sample.id,
                  pop = gbhap[match(PCA$sample.id,gbhap$genbank_id),"region"],
                  pre = gbhap[match(PCA$sample.id,gbhap$genbank_id),"prefix"],
                  afronly = gbhap[match(PCA$sample.id,gbhap$genbank_id),"africa_breakdown"],
    EV1 = PCA$eigenvect[,1],    # the first eigenvector
    EV2 = PCA$eigenvect[,2],    # the second eigenvector
    stringsAsFactors = FALSE)
tab$region<- factor(tab$region, levels = c("Asia", "Europe", "Africa"))
tab$africa_breakdown<- factor(tab$africa_breakdown, levels = c("Asia", "Europe", "L0", "L1","L2","L3","L4","L5","L6"))


myColors <- brewer.pal(9,"Set1")
names(myColors) <- levels(tab$region)
colScale <- scale_colour_manual(name = "region",values = myColors)

ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=region))+colScale
```
The regional PCA is interesting. If we provide a breakdown just by Africa:
```{r, echo=FALSE}
names(myColors) <- levels(tab$africa_breakdown)
colScale <- scale_colour_manual(name = "africa_breakdown",values = myColors)
ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=africa_breakdown))+colScale

africa_only<-levels(factor(gbfac$genbank_id[gbfac$region=='Africa']))
my_subset<-africa_only
```
This makes more sense if we view. L0
http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2427203/bin/gr1.jpg


Now let's just at PCAs of the regions
```{r doregion, echo=FALSE}

PCA<-snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,eigen.cnt=2,sample.id = my_subset,snp.id = snp_subset)
tab <- data.frame(sample.id = PCA$sample.id,
                  pop = gbhap[match(PCA$sample.id,gbhap$genbank_id),"region"],
                  pre = gbhap[match(PCA$sample.id,gbhap$genbank_id),"prefix"],
    EV1 = PCA$eigenvect[,1],    # the first eigenvector
    EV2 = PCA$eigenvect[,2],    # the second eigenvector
    stringsAsFactors = FALSE)
ggplot(tab,aes(EV1,EV2))+geom_point(aes(color=prefix))

```
Europe
```{r, echo=FALSE}
my_subset<-levels(factor(gbfac$genbank_id[gbfac$region=='Europe']))[sample(1:length(levels(factor(gbfac$genbank_id[gbfac$region=='Europe']))),1000)]
```

```{r europe, ref.label='doregion'}
```

#plot the PCA
#RV <- snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16)


#RV <- snpgdsPCA(genofile,autosome.only=FALSE,num.thread=16,missing.rate=.1,eigen.cnt=2)

```

There are `r length(unique(gball$snpid))` mutations in the GenBank set over `r length(unique(gball$tpos))` which is a rate of `r length(unique(gball$tpos))/16568` per bp. `sum(table(gbfac$snpid)==1)` of these are truly priviate mutations belonging to only one sequence.

So in contrast to the nuclear genes 51,217,066 rs numbers in dbSNP out of 3,064,641,871 non-N bases which is a rate of `r 51217066/3064641871`

D-Loop gets triple stranded during replication, with hypervariable regions

phenylanlinian to proline is with coding areas
within coding regions breakout tRNA




How many MT snps are in dbSNP?
```{r, echo=FALSE}

snps <- SNPlocs.Hsapiens.dbSNP141.GRCh38
chMTsnps <- snplocs(snps,"chMT")
```

There are `r as.numeric(snpcount(snps)[["chMT"]])` mitochondrial snp positions in dbSNP and `r length(unique(sort(gball$tpos)))`

There are `r length(unique(gball$snpid))` distinct mutations in the gb set.

sum(unique(sort(chMTsnps$loc)) %in% unique(sort(gball$tpos)))
sum(unique(sort(gball$tpos)) %in% unique(sort(chMTsnps$loc)))
library(Vennerable)

3243A>G mutation


Are there associations between SNPs that are not defined by the haplogroups themselves? Market basket analysis is one way to look at this, where we consider that we have 30,000 shoppers choosing among 9919 SNPs. Market basket is a type of association rule mining using in economics, this is often called the diapers and beer study, since it discovered those two items are most strongly associated.
```{r, echo=FALSE}
imatrix<-as(numsparsey, "itemMatrix")
dimnmaes(imatrix)[[2]]<-levels(gbfac$snpid)
dimnames(imatrix)[[2]]<-levels(gbfac$snpid)

rules <- apriori(imatrix)
summary(rules)
rules.sorted<-sort(rules,by="lift")
```

```{r, echo=FALSE}
dbDisconnect(con)
```